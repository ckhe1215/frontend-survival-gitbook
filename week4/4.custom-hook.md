# 4. useRef & Custom Hook

## useRef

- 렌더링이 불필요한 값을 참조하게 해주는 훅

```js
import { useRef } from 'react';

const ref = useRef(initialValue)
```

- `initial value`로 초기화된 `current` 속성을 가지고 있는 `ref` 객체를 리턴
- 다음 렌더링에서도 `useRef`는 동일한 객체를 리턴하기 때문에 `current` 속성에 저장한 값은
나중에 읽어들일 수 있음
- `ref`의 변화는 리렌더링을 trigger하지 않는다는 점에서 `state`와 차이가 있음

`ref`와 다른 변수들의 차이

1. 일반 변수와 달리 매 렌더링마다 리셋되지 않고 값이 저장됨
2. state와 달리 리렌더링되지 않음
3. 외부 변수와 달리 컴포넌트 간에 공유되지 않음

### ref로 DOM 조작하기

``` js
function MyComponent() {
  const inputRef = useRef(null);
  // ...
  return <input ref={inputRef} />;
}

function handleClick() {
  inputRef.current.focus();
}
```

1. null값을 초기값으로 갖는 ref 객체 생성
2. ref 객체를 ref attribute로 넘김
3. DOM노드가 스크린에 생성되고 나면 current 속성에 DOM 노드가 저장됨
4. ref의 current값으로 DOM 노드를 조작할 수 있음
5. 노드가 스크린에서 사라지면 current값은 null이 됨

### 렌더링 중에 ref 값을 read/write 하지 않기

- 리액트 컴포넌트는 항상 순수함수여야함
- 인풋이 동일하다면 항상 동일한 결과(JSX)를 리턴해야함
- 다른 순서나 다른 인수를 사용하여 호출해도 다른 호출의 결과에 영향을 미치지 않아야 함
- 렌더링 중에 값을 변경하거나 사용해야한다면 state를 쓸 것

``` js
function MyComponent() {
  // ...
  // 🚩 Don't write a ref during rendering
  myRef.current = 123;
  // ...
  // 🚩 Don't read a ref during rendering
  return <h1>{myOtherRef.current}</h1>;
}

function MyComponent() {
  // ...
  useEffect(() => {
    // ✅ You can read or write refs in effects
    myRef.current = 123;
  });
  // ...
  function handleClick() {
    // ✅ You can read or write refs in event handlers
    doSomething(myOtherRef.current);
  }
  // ...
}
```

### ref contents의 재생성 피하기

보통 ref의 초기값은 재렌더링시 무시됨

그러나 아래 코드는 매번 `new VideoPlayer()`를 생성하게 됨

```js
function Video() {
  const playerRef = useRef(new VideoPlayer());
  // ...
```

불필요한 객체를 매번 생성하는 것은 낭비이므로 아래와 같이 작성

```js
function Video() {
  const playerRef = useRef(null);
  if (playerRef.current === null) {
    playerRef.current = new VideoPlayer();
  }
  // ...
```

일반적으로 ref 값을 렌더링하는 동안 쓰지 않는 것이 좋지만 여기서는 실행과가 항상 동일한 값을
리턴하기 때문에 OK

## Custom Hook

나만의 훅을 만들어 컴포넌트 간에 로직을 재사용할 수 있음


## Hook의 규칙
