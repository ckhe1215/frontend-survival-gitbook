# 2. TypeScript

키워드

- REPL
- TypeScript
  - 타입 추론
  - Interface vs Type
  - Union Type vs Intersection Type
  - Optional Parameter

## 타입스크립트, 왜 쓰는가?

- 편리한 자동완성
- 실시간 오류검사

## REPL

- Read-Eval-Print-Loop
- 사용자의 입력을 받아 평가하고 결과를 리턴하는 인터렉티브 프로그래밍 환경
- ts-node를 실행해 타입스크립트 REPL 사용 가능 `npx ts-node`

## 타입 추론

타입스크립트는 자료의 뒤에 타입을 명시

타입을 명시하지 않아도 값을 통해 자동으로 타입을 결정해주기도 함

```ts
const name: string = '홍길동';
const name = '홍길동';
// 위의 코드와 아래코드는 같다.
```

## 타입

### 원시타입

```ts
let name: string;
let age: number;
let isAdult: boolean;

name = "홍길동";
age = 20;
isAdult = true;
```

### 배열

`number[]` 또는 `Array<number>` 의 형태로 사용

``` ts
let numbers: number[];
numbers = [1, 2, 3];
```

### 튜플

<!-- https://ujeon.medium.com/typescript-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B8%B0%EC%B4%88-6-536e17559358 -->

<!-- https://velog.io/@from_numpy/TypeScript-Tuple%ED%8A%9C%ED%94%8C -->

길이와 타입이 고정된 배열

순서에 맞지 않게 데이터를 넣으면 에러 표시

``` ts
let user1: [number, string, string];
user1 = [1, 'setType77@example.com', '1q2w3e4r'];
```

#### 한계점

`push` 메서드를 사용하면 정의와 상관없이 배열의 길이가 늘어남

``` ts
let user1: [number, string, string];
user1 = [1, 'setType77@example.com', '1q2w3e4r'];

user1.push('fake'); // 에러없이 컴파일됩니다.
```

#### 해결방안

튜플 선언시에 `readonly` 사용

``` ts
type UserInfo = readonly [number , string, string ,string , boolean]; // 배열 앞에 readonly 적용

let userInfo1 : UserInfo = [1, 'user1@example.com' , 'abcd123' , '1999-01-01' , true];

userInfo1.push('hello'); // Error
```

### any

어떤 값의 타입이 any이면 타입 검사를 실행하지 않음

### 함수

매개변수와 리턴값에 타입을 표기할 수 있음

``` ts
// 매개변수 타입 표기
function greet(name: string) {
  console.log("Hello, " + name.toUpperCase() + "!!");
}

// 반환 타입 표기
function getFavoriteNumber(): number {
  return 26;
}
```

### 객체

## type vs. interface

## Union vs. Intersection