# 2. React Testing Library

- React Testing Library
- given - when - then 패턴
- Mocking
- Test fixture

## React Testing Library

리액트 컴포넌트를 사용자 입장에 가깝게 테스트 할 수 있는 도구

- Implementation Driven Test(구현 주도 테스트) : 주로 애플리케이션이 어떻게 작동하는지에 대해 초점을 두어 테스트 작성
- Behavior Driven Test(행위 주도 테스트) : 사용자가 애플리케이션을 이용하는 관점에서 사용자의 실제 경험 위주로 테스트를 작성

- React Testing Library는 Behavior Driven Test 방법론을 따르는 테스트를 작성하는데 적합
- `jsdom`이라는 라이브러리를 통해 실제 브라우저 DOM을 기준으로 테스트를 작성하기 때문
- 어떤 React 컴포넌트를 사용하는지보다, 사용자 브라우저에서 렌더링하는 실제 HTML 마크업의 모습이 어떤지에 대해서 테스트하기 용이
- `Enzyme`이라는 테스트 라이브러리는 리액트 VDOM을 기준으로 테스트를 작성하여 Implementation Driven Test 방법론을 따름

### React Testing Library 주요 API

- `render()` 함수 : DOM에 컴포넌트를 렌더링
- `fireEvent` 객체 : 특정 이벤트를 발생시킴
- 쿼리함수 : DOM에서 특정 영역을 선택

### `render()` 함수

- `@testing-library/react` 모듈로부터 바로 임포트 가능
- 인자로 렌더링할 React 컴포넌트를 넘김
- React Testing Library사 제공하는 모든 쿼리함수와 기타 유틸리티 함수를 담고 있는 객체를 리턴하므로 destructuring 문법으로 `render()` 함수가 리턴한 객체로부터 원하는 쿼리함수만 얻어올 수 있음

### 쿼리함수

- 렌더링된 DOM노드에 접근하여 엘리먼트를 가져오는 메서드
- `쿼리 타입`/`타겟 개수`/`타겟 유형`으로 구성 ex) `get``All``ByRole`

쿼리타입

- `get` : 동기적으로 처리되며 타겟을 찾지못할시 에러를 던짐
- `find` : 비동기적으로 처리되며 타겟을 찾지 못할시 에러를 던짐
- `query` : 동기적으로 처리되며 타겟을 찾지 못할시 `null`을 반환

타겟의 개수

- 다수의 엘리먼트가 탐색되는 상황이라면 뒤에 `All`을 붙임

타겟 유형

- `ByRole`, `ByLabelText`, `ByPlaceholderText`, `ByText`, `ByDisplayValue`, `ByAltText`, `ByTitle`, `ByTestId`

### 정적 컴포넌트 테스팅

Page Not Found 컴포넌트 예제

```js
import React from "react";

function NotFound({ path }) {
  return (
    <>
      <h2>Page Not Found</h2>
      <p>해당 페이지({path})를 찾을 수 없습니다.</p>
      <img
        alt="404"
        src="https://media.giphy.com/media/14uQ3cOFteDaU/giphy.gif"
      />
    </>
  );
}
```

`h2`가 렌더링 되고 있는지 검증

```js
import React from "react";
import { render } from "@testing-library/react";
import NotFound from "./NotFound";

describe("<NotFound />", () => {
  it("renders header", () => {
    const { getByText } = render(<NotFound path="/abc" />);
    const header = getByText("Page Not Found");
    expect(header).toBeInTheDocument();
  });
});
```

1. `<NotFound />` 컴포넌트를 임포트해서 `render()`의 인자로 넘긴 후에 리턴 객체로부터 `getByText()` 함수를 얻음
2. 화면에서 검색할 텍스트인 `Page Not Found`를 `getByText()`에 인자로 넘겨 `<h2/>` 엘리먼트를 얻음
3. `jest-dom`의 `toBeInTheDocument()` matcher 함수를 이용해서 해당 `<h2/>` 엘리먼트가 화면에 존재하는 검증

`p`가 렌더링 되고 있는지 검증

```js
it("renders paragraph", () => {
  const { getByText } = render(<NotFound path="/abc" />);
  const paragraph = getByText(/^해당 페이지/);
  expect(paragraph).toHaveTextContent("해당 페이지(/abc)를 찾을 수 없습니다.");
});
```

1. 정규식으로 `<p/>`안의 텍스트가 포함된 요소를 가져옴
2. 가져온 요소의 텍스트가 예상과 일치하는지 검증

`img`가 렌더링 되고 있는지 검증

```js
it("renders image", () => {
  const { getByAltText } = render(<NotFound path="/abc" />);
  const image = getByAltText("404");
  expect(image).toHaveAttribute(
    "src",
    "https://media.giphy.com/media/14uQ3cOFteDaU/giphy.gif"
  );
});
```

1. 이미지 태그는 텍스트가 없기 때문에 `alt`속성값을 이용
2. `jest-dom`의 `toHaveAttribute()` matcher 함수를 이용해서 `<img/>` 엘리먼트의 `src` 속성값이 정확한지 검증

### 동적 컴포넌트 테스팅

내부 상태에 따라 UI에 변화가 생길 수 있는 컴포넌트 테스트

```js
import React, { useState } from "react";

function LoginForm({ onSubmit }) {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  return (
    <>
      <h2>Login</h2>
      <form onSubmit={onSubmit}>
        <label>
          이메일
          <input
            type="email"
            placeholder="user@test.com"
            value={email}
            onChange={({ target: { value } }) => setEmail(value)}
          />
        </label>
        <label>
          비밀번호
          <input
            type="password"
            value={password}
            onChange={({ target: { value } }) => setPassword(value)}
          />
        </label>
        <button disabled={!email || !password}>로그인</button>
      </form>
    </>
  );
}
```

이메일과 비밀번호를 입력해야 로그인 버튼이 활성화 되는 예제

```js
import React from "react";
import { render, fireEvent } from "@testing-library/react";
import LoginForm from "./LoginForm";

describe("<LoginForm />", () => {
  it("enables button when both email and password are entered", () => {
    const { getByText, getByLabelText } = render(
      <LoginForm onSubmit={() => null} />
    );

    const button = getByText("로그인");
    const email = getByLabelText("이메일");
    const password = getByLabelText("비밀번호");

    expect(button).toBeDisabled();

    fireEvent.change(email, { target: { value: "user@test.com" } });
    fireEvent.change(password, { target: { value: "Test1234" } });

    expect(button).toBeEnabled();
  });
});
```

1. 로그인 버튼의 경우에는 `getByText()` 쿼리 함수를 통해 선택하고, 이메일과 비밀번호 입력칸은 `getByLabelText()` 쿼리 함수로 선택
2. jest-dom의 `toBeDisabled()`와 `toBeEnabled()` matcher 함수를 통해서 로그인 버튼의 활성화 여부를 이벤트 발생 전후로 검증
3. 두 개의 입력칸에 change 이벤트를 발생시키기 위해서 `fireEvent.change()` 함수를 사용

로그인 버튼을 클릭했을때 prop으로 넘긴 `onSubmit` 함수가 호출되는지 검증

```js
it("submits form when buttion is clicked", () => {
  const obSubmit = jest.fn();
  const { getByText, getByLabelText } = render(
    <LoginForm onSubmit={obSubmit} />
  );

  const button = getByText("로그인");
  const email = getByLabelText("이메일");
  const password = getByLabelText("비밀번호");

  fireEvent.change(email, { target: { value: "user@test.com" } });
  fireEvent.change(password, { target: { value: "Test1234" } });

  fireEvent.click(button);

  expect(obSubmit).toHaveBeenCalledTimes(1);
});
```

## Mocking

위의 예제에서 onSubmit에 전달할 함수를 `jest.fn()`을 이용해서 만들었음

mocking: 단위테스트를 작성할 때 해당 코드가 의존하는 부분을 가짜(mock)로 대체하는 기법

<!-- https://www.daleseo.com/jest-fn-spy-on/ -->